\subsection{Smart-contract implementation}


\subsubsection{Accounts}

There are 2 kinds of accounts:
\begin{itemize}
  \item Personal: created for each client, directly belongs to that client;
  \item Robot: created by client, doesn't belong directly to that client (and anyone else); represents smart contract.
\end{itemize}

Robot account should contain, aside from token mapping:
\begin{itemize}
  \item Data storage for smart contract state;
  \item The code to control the account, compiled to Plutus Core language.
\end{itemize}

The Plutus Core language allows declaring a module with exported (public) methods.
These methods will be the public API for the account.

One can evaluate the Plutus Core code itself (not just call public methods) if account directly belongs to her.
Personal accounts don't have any persistent associated code to control them.

\subsubsection{Scripting}

The Plutus language will be used to program Robot nodes.
Any interaction with account is done via Plutus code.

The evaluation cost is collected and summed into Fee.

"Sandbox run" can be performed, to check costs and programming errors.

We will call natively-implemented functions to be called from Plutus Core "NIFs".

\subsubsection{NIFs}

NIF is an (ortogonal to each other) action to be invoked on Account.
NIF is the only source of changes in Account.

Any operation on the Account to be implemented should be represented as a call to NIF OR as a sequence of NIF-calls.
This will allow us to reason about security/validity of operations with more confidence and limit the access and scope of each operation.

Each NIF has an invocation cost.

\subsubsection{Transaction}

We will cover "simple money transfer" and "data disclosure" transactions in this section.

"Simple money transfer" transactions will be implemented as transactions with empty "function call" field.

Transferral transaction must contain:
\begin{itemize}
  \item Sender signature;
  \item Receiver signature;
  \item Amount and kind of funds transferred (must be non-zero overall);
  \item "Nonce" to prevent double-invocation.
  \item (Optional) textual message for the receiver;
  \item (Optional) function call to be invoked upon transaction approval.
  \item Digest of all other fields, encrypted with Sender private key.
\end{itemize}

Transaction is the only way for accounts to interact.

Function call (if present) will contain the name of exported function and arguments to be supplied upon invocation.

The function would be invoked like that:

\begin{verbatim}
function-name(Seller-signature, amount, value1, value2, ..., valueN)
\end{verbatim}

On successful code invocation, money will be transmitted to the Target account and the costs will be demanded from the Sender.
If code fails, the transaction is not published as successful and is rejected.

If there is not enough money supplied for the operation or the code raised an error, whole transaction will fail.

If there is no function call in transaction, the code invocation is assumed successful.

The fee for transaction approval will depend on NIFs invoked and will have its cost calculated as \verb|K * (NifInvoked + C * sqr(NifInvoked))| where
\begin{itemize}
    \item \verb|K| is a global tuning parameter;
    \item \verb|C| is a parameter to cut off long transactions. It is small enough, so fast-ending transactions will not notice it; in the same time big transactions (like the one trying to evaluate \verb|akkermann(10, 10)|) will run out of gas.
\end{itemize}

\subsubsection{Smart-contract mechanics}

We assume that we have 2 sides:
\begin{itemize}
  \item Buyer
  \item Seller.
\end{itemize}

"Gas" below is the estimation of the operation cost. The name and idea is taken from Etherium.

Smart contracts would work as follows. Seller invokes a transaction which runs code directly on his account, that constructs a robot with following exported methods

\begin{itemize}
  \item \begin{verbatim} start-trade(); \end{verbatim}
  \item \begin{verbatim} accept-encrypted(encrypted-mroot, size); \end{verbatim}
  \item \begin{verbatim} handshake(); \end{verbatim}
  \item \begin{verbatim} reject(sk, block, proof-enc, proof-plain); \end{verbatim}
  \item \begin{verbatim} check-time(), \end{verbatim}
  \item \begin{verbatim} cancel(), \end{verbatim}
\end{itemize}
carrying \verb|Fee + Gas| amount of currency and some \verb|predicate| to check the data if applicable.

This robot is initilized with following data:
\begin{itemize}
  \item Cost in tokens;
  \item Size of plain data;
  \item Merkle tree root of encrypted data;
  \item Merkle tree root of plain data.
\end{itemize}

Here is the state machine of that Robot-account:

\begin{verbatim}
  (0) Account has just been created.
    "start-trade" from Buyer
      WHEN transferred amount = Sum + Fee
        Notify Seller
        AND GOTO 1

  (1) The trade is started.
    "accept-encrypted(encrypted-mroot, size)" from Buyer
      IF encrypted Merkle root and size are the same as initially set in Robot state,
        GOTO 2
      ELSE
        GOTO 7

    "check-time" from Seller or Buyer
      when time-spent > TIMEOUT
        GOTO 7

  (2) Data was transferred. Off the band, the symmetric key is sent.
    "reject(sk, block, encrypted-proof, plain-proof)" from Buyer
      GOTO 3

    "handshake" from Buyer
      GOTO 4

  (3) Arbitration.
    The robot performs check.
    If it finds that Buyer is right (block invalidates either of proofs OR the predicate fails),
      GOTO 6
    else if Seller is right
      GOTO 5

  (4) Cleanup I.
    (Sum + Fee) is sent to Seller.
    Fee is sent to Buyer.
    The account is closed.

  (5) Cleanup II.
    All remaining money is sent to Seller.
    The account is closed.

  (6) Cleanup III.
    All remaining money is sent to Buyer.
    The account is closed.

  (7) Cleanup VI.
    Fee is sent to Seller.
    (Sum + Fee) is sent to Buyer.
    The account is closed.

\end{verbatim}

\subsubsection{Example}

Lets assume there are:
\begin{itemize}
  \item Seller, which has declared that he has his students' Linear Algebra marks for Nov, 2018 worth 500 tokens (signed in some private Merkle tree);
  \item Buyer, which has 600 tokens available.
  \item Robot, which is a smart account created by Seller.
\end{itemize}

We will consider three cases:
\begin{itemize}
  \item Seller sends nothing at all;
  \item Seller tried to send Buyer encrypted garbage instead of data;
  \item Buyer tried to blame Seller in giving her invalid data with data being completely valid (in terms of signature and predicate).
\end{itemize}

All trades will have same initial part, so we will branch when nessessary.
The trades will go as follows:
\begin{itemize}
  \item (Optionally) Seller formulates a predicate to check that data corresponds its description OR uses universal truth as predicate.

  \item She determines the Fee to be 20 tokens and adds 10 tokens as Gas.

  \item Then she creates Robot using the scheme above with 20 + 10 tokens and the predicate.

  \item Buyer accepts the trade and sends \verb|start-trade()| to Robot along with 500 + 20 tokens.

  \begin{enumerate}
    \item Seller sends badly sized data:
      \begin{itemize}
        \item The size of transferred data is invalid.
        \item The trade is stalled until time is out.
        \item Buyer is able to send \verb|check-time()| message to revert trade and to return the money she sent.
      \end{itemize}
    \item Seller tries to send garbage or one of blocks decrypts to garbage:
      \begin{itemize}
        \item Buyer finds that at least one block signature is invalid in either form.

        \item She invokes \verb|reject(sk, block, encrypted-proof, plain-proof)| to start arbitration.

        \item Robot checks that block falsifies proofs and that Buyer was right.

        \item Robot returns all remaining funds to Buyer.
      \end{itemize}
    \item Buyer tries to blame Seller with valid data:
      \begin{itemize}
        \item Buyer selects the block to call "invalid".

        \item Then she invokes \verb|reject(unencrypted-block, proof)| to start arbitration.

        \item The smart account performs \verb|check-block-and-proof(block, proof)| and finds that Buyer was not right.

        \item Then it send 500 tokens to Seller and all remaining currency to Buyer.
      \end{itemize}
    \item Buyer receives the data, but remains silent:
      \begin{itemize}
        \item Seller after some time calls \verb|check-time()|.

        \item If the timeout is expired, 500 tokens are sent to Seller.

        \item All remaining currency is sent to Buyer.
      \end{itemize}
  \end{enumerate}

\end{itemize}
