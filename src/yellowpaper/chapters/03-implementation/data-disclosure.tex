\subsection{Data Disclosure}
\label{sec:DataDisclosure}
The process of data disclosure involves direct communication between a particular Educator, willing to disclose a part of the data, and an interested party~\tParty{B} (e. g. a recruiter), willing to pay for this data. Suppose an Educator~\tParty{E} has some data~$D$. To mitigate the risk of secondary market creation, one should ensure that the majority of the data remains in the private blocks. We propose to increase the cost of the data exponentially to its size, thus incentivizing the buyers to make as accurate requests as possible.

 Before the deal \tParty{E} ought to perform some preparation steps. \tParty{E} should:
\begin{enumerate}
\item Divide~$D$ into $N$ chunks of size no more than 1~KiB:

\begin{equation}
D = \Concat_{i=1}^N d_i, \quad \SizeOf(d_i) \leq 1~\mathrm{KiB}
\end{equation}

\item Compute a Merkle root of the unencrypted chunks:
\begin{equation}
R_0 = \Root(\MerkleTree(\Lock{D}))
\end{equation}

\item Generate a symmetric key $k$
\item Encrypt each~$d_i$ with $k$ and make an array of encrypted chunks:
\begin{equation}
\Lock{D} = \{ \Encrypt_\Key{k}(d_1),\ \Encrypt_\Key{k}(d_2),\ ...,\ \Encrypt_\Key{k}(d_N) \}
\end{equation}

\item Compute a Merkle root of the encrypted chunks:
\begin{equation}
R = \Root(\MerkleTree(\Lock{D}))
\end{equation}

\item Determine the size of the data she is going to reveal:
\begin{equation}
s = \SizeOf(\Lock{D})
\end{equation}

\item Calculate the cost of the data ($\alpha$ is some constant coefficient):
\begin{equation}
C_D = \alpha \operatorname{exp}(s)
\end{equation}
\end{enumerate}

The protocol fairness is guaranteed by a contract on the public chain. The contract is able to hold money and is stateful: it is capable of storing a log $L$ with data. All the data that parties send to the contract are appended to $L$.

\begin{enumerate}
\item \tParty{E} creates a contract on the public chain and sends the following data to the contract: $\Sign_\Party{E}(C_D,\ \SizeOf(\Lock{D}), R, R_0)$. She also sends a predefined amount of money $C_E$ to the contract address. $C_E$ is a security deposit: if \tParty{E} tries to cheat, she would lose this money.
\item The buyer generates a new keypair ($\PubKey{B},\ \SecretKey{B}$), and sends $C_D$ worth of money to the contract address. Along with the money, \tParty{B} sends the public key $\PubKey{B}$ of the newly generated keypair, and the size of the data.
\item \tParty{E} transfers the encrypted data chunks $\Lock{D}$ to the buyer. \tParty{B} computes the Merkle root $R'$ and the size $s'$ of the received data $\Lock{D}'$:
\begin{equation}
R' = \Root(\MerkleTree(\Lock{D}'))
\end{equation}
\begin{equation}
s' = \SizeOf(\Lock{D}')
\end{equation}
\item \tParty{B} makes a transaction with a receipt $\Sign_\Party{B}(\{R',\ s'\})$ to the contract address. The parties can proceed if and only if the following is true:
\begin{equation}
(R' = R)\ \land\ (s' = s)
\end{equation}
Otherwise, the protocol halts.
\item \tParty{E} sends $\Sign_\Party{E}(\Encrypt_\Party{B}(k))$ to the contract.
\item \tParty{B} decyphers and checks the received data. In case some data chunk $e_i \in \Lock{D}$ is invalid, \tParty{B}~sends a transaction with~$\{\SecretKey{B},\ e_i,\ \Path(e_i,\ \MerkleTree(\Lock{D}))\}$ to the contract. By doing so, \tParty{B}~reveals the data chunk~$d_i$ corresponding to the encrypted chunk~$e_i$.  She also shares proof that~$e_i$ was indeed part of a  Mekle tree with root~$R$. The contract checks the validity of $d_i$ and decides whether \tParty{B}~has rightfully accused~\tParty{E} of cheating.
\end{enumerate}

The on-chain communications of the parties (steps 2, 4, 5, 6) are bounded by a time frame $\tau$. In order for the transaction to be valid, the time $\Delta t$ passed since the previous on-chain step has to be less than or equal to $\tau$. In case $\Delta t > \tau$ the communication between the parties is considered over, and one of the protocol exit points is automatically triggered. The protocol exit points are described in detail in Table~\ref{table:data-disclosure-exit-points}.

\begin{table}[ht]
  \caption{Data disclosure protocol exit points}
  \label{table:data-disclosure-exit-points}
  \tabulinesep=3pt
  \begin{longtabu} to \textwidth {| X[2, c] | X[1, c] | X[10, l] |}
    \hline
    \textbf{Condition} & \textbf{Step} & \textbf{Consequence}\\ \hline
    \endhead
    $\Delta t > \tau$ & 2 & \multirow{4}{=}{\tParty{B}, \tParty{E} get their money back because \tParty{E}~wasn't able to correctly transfer the data to~\tParty{B}.} \\ \cline{1-2}
    $\Delta t > \tau$ & 4 & \\ \cline{1-2}
    $R' \neq R$ & 4 & \\ \cline{1-2}
    $s' \neq s$ & 4 & \\ \hline
    $\Delta t > \tau$ & 5 & \tParty{B}, \tParty{E} get their money back because \tParty{B}~has received the encrypted data, but \tParty{E}~nas not been able to share the key $k$ for it \\ \hline
    $\Delta t > \tau$ & 6 & \tParty{E} gets $C_E$ and $C_D$: \tParty{E} correctly shared data to \tParty{B} \\ \hline
    \multicolumn{2}{|c|}{Protocol finishes} & The dispute situation. In case \tParty{B} proofs \tParty{E} cheated, \tParty{E} loses her security deposit $C_E$. Otherwise, \tParty{E} receives both $C_E$ and $C_D$. \\ \hline
  \end{longtabu}
\end{table}
